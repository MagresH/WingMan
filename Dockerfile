import numpy as np import numpy.random as npr # Parametry lambda_ = 1 mu = 2 # Zakładamy: 10 kroków czasowych na jednostkę czasu ticks_per_unit = 10 T = 5 # max czas symulacji w jednostkach czasu steps = T * ticks_per_unit # liczba kroków czasowych samples = 10000 # liczba trajektorii # Inicjalizacja Xt = np.zeros((steps + 1, samples)) Yt = np.zeros((steps + 1, samples)) Zt = np.zeros((steps + 1, samples)) # Symulacja for t in range(1, steps + 1): Xt[t] = Xt[t - 1] + npr.poisson(lambda_ / ticks_per_unit, samples) Yt[t] = Yt[t - 1] + npr.poisson(mu / ticks_per_unit, samples) Zt = Xt + 2 * Yt # Pomocnicze indeksy czasów a, b = 2, 2 e, n = 3, 1 i, j, h = 1, 4, 2 tick = lambda t: t * ticks_per_unit # konwersja na indeks # (a) Intensywność Z_t intensywnosc_Z = lambda_ + 2 * mu print(f"(a) Intensywność Z_t: {intensywnosc_Z}") # (b) P(X_a = c, X_b = d) c, d = 2, 3 a_idx, b_idx = tick(a), tick(b) count_b = np.sum((Xt[a_idx] == c) & (Xt[b_idx] == d)) print(f"(b) P(X_a={c}, X_b={d}) ≈ {count_b / samples:.4f}") a3 = 0 for i in range(10000): if Xt[20,i]==2 and Xt[20,i]==3: a3 += 1 print( a3/10000) # (c) P(X_e = g | Z_e = f) f, g = 4, 4 e_idx = tick(e) num = np.sum((Xt[e_idx] == g) & (Zt[e_idx] == f)) den = np.sum(Zt[e_idx] == f) p_c = num / den if den > 0 else 0 print(f"(c) P(X_e={g} | Z_e={f}) ≈ {p_c:.4f}") a4,a5 = 0, 0 for i in range(10000): if Xt[30,i]==4 and Zt[30,i]==4: a4 += 1 if Zt[30,i]==4: a5 += 1 print( a4/a5) # (d) P(Z_{n+1} = q | X_n = p) n = 1 p, q = 1, 2 n_idx = tick(n) n1_idx = tick(n + 1) num = np.sum((Xt[n_idx] == p) & (Zt[n1_idx] == q)) den = np.sum(Xt[n_idx] == p) p_d = num / den if den > 0 else 0 print(f"(d) P(Z_{n+1}={q} | X_n={p}) ≈ {p_d:.4f}") a4 = 0 a5 = 0 n = 1 p, q = 1, 2 for i in range(10000): if Zt[20,i]==2 and Xt[10,i]==1: a4 += 1 if Xt[10,i]==1: a5 += 1 print( a4/a5) # (e) P(Z_j = k | Z_i = m) i, j = 1, 4 k, m = 1, 2 i_idx, j_idx = tick(i), tick(j) num = np.sum((Zt[i_idx] == m) & (Zt[j_idx] == k)) den = np.sum(Zt[i_idx] == m) p_e = num / den if den > 0 else 0 print(f"(e) P(Z_j={k} | Z_i={m}) ≈ {p_e:.4f}") i, j = 1, 4 k, m = 1, 2 a4,a5 = 0, 0 for i in range(10000): if Zt[40,i]==1 and Zt[10,i]==2: a4 += 1 if Zt[10,i]==2: a5 += 1 print( a4/a5, ) # (f) P(Z_h = k, Z_j - Z_i = m) i, j = 1, 4 k, m = 1, 2 h_idx = tick(h) delta_Z = Zt[j_idx] - Zt[i_idx] num = np.sum((Zt[h_idx] == k) & (delta_Z == m)) p_f = num / samples print(f"(f) P(Z_h={k}, Z_j - Z_i={m}) ≈ {p_f:.4f}") # Proces Wienera Wt = np.zeros((steps + 1, samples)) for t in range(1, steps + 1): dW = npr.normal(0, np.sqrt(1 / ticks_per_unit), samples) # przyrosty N(0, dt) Wt[t] = Wt[t - 1] + dW # (g) Prawdopodobieństwo złożone P(W_a = c, X_b = d) a3 = 0 a, b = 2, 2 c, d = 2, 3 for i in range(10000): if Wt[20,i]==2 and Xt[20,i]==3: a3 += 1 print( a3/10000, ' =P(Z1==2,Z2==5)') # (i) P(Z_j = k | Z_i = m) a4,a5 = 0, 0 i, j = 1, 4 k, m = 1, 2 for i in range(10000): if Zt[40,i]==1 and Zt[10,i]==2: a4 += 1 if Zt[10,i]==2: a5 += 1 print( a4/a5, ' = P(X1=1,Z1=2) / P(Z1=2) = P(X1==1 | Z1==2)')

import numpy as np import matplotlib.pyplot as plt # Stałe a, b, c, d = 4, 5, -2, -1 lambda_poisson = (1 + b) / 2 # intensywność dla Poissona # Funkcja generująca próbki X_t def generate_X(t, n_samples=10000): U = np.random.uniform(0, a, size=n_samples) # U ~ U[0, a] V = np.random.poisson(lam=lambda_poisson, size=n_samples) # V ~ Poiss((1 + b)/2) return c * t + U + d * V # Wartości czasu t t_values = np.linspace(0, 10, 100) E_Xt = [] Var_Xt = [] P_Xt_range = [] # Granice z podpunktu (g) lower_bound = min(5*a, c, b, d) / 2 upper_bound = max(5*a, c, b, d) / 2 # Obliczenia dla każdego t for t in t_values: Xt = generate_X(t) E_Xt.append(np.mean(Xt)) Var_Xt.append(np.var(Xt)) P_Xt_range.append(np.mean((Xt > lower_bound) & (Xt < upper_bound))) # Wykresy plt.figure(figsize=(12, 8)) plt.subplot(3, 1, 1) plt.plot(t_values, E_Xt) plt.title("E[X_t]") plt.grid() plt.subplot(3, 1, 2) plt.plot(t_values, Var_Xt, color='orange') plt.title("Var[X_t]") plt.grid() plt.subplot(3, 1, 3) plt.plot(t_values, P_Xt_range, color='green') plt.axhline(0.5, linestyle='--', color='gray') plt.title(f"P({lower_bound:.2f} < X_t < {upper_bound:.2f})") plt.grid() plt.tight_layout() plt.show()

# --- Wczytywanie trajektorii --- with open('losowe_dane_3.txt', 'r') as f: trajektorie = [list(map(int, line.strip().split(','))) for line in f] # --- RozkĹ‚ad poczÄ…tkowy --- stany_poczatkowe = [traj[0] for traj in trajektorie] p_0 = stany_poczatkowe.count(0) / len(stany_poczatkowe) p_1 = stany_poczatkowe.count(1) / len(stany_poczatkowe) p_2 = stany_poczatkowe.count(2) / len(stany_poczatkowe) P_X0 = {0: p_0, 1: p_1, 2: p_2} # --- Macierz przejĹ›Ä‡ --- licznik_przejsc = { (0,0): 0, (0,1): 0, (0,2): 0, (1,0): 0, (1,1): 0, (1,2): 0, (2,0): 0, (2,1): 0, (2,2): 0 } licznik_stanow = {0: 0, 1: 0, 2: 0} for traj in trajektorie: for i in range(len(traj) - 1): a, b = traj[i], traj[i + 1] licznik_przejsc[(a, b)] += 1 licznik_stanow[a] += 1 # Macierz przejĹ›Ä‡ - normalizacja P_transitions = {} for i in [0, 1, 2]: P_transitions[i] = {} for j in [0, 1, 2]: if licznik_stanow[i] > 0: P_transitions[i][j] = licznik_przejsc[(i, j)] / licznik_stanow[i] else: P_transitions[i][j] = 0.0 # --- Obliczenia --- # a) P(X2 = 1 | X0 = 1) P_X2_given_X0_1 = 0.0 for k in [0, 1, 2]: P_X2_given_X0_1 += P_transitions[1][k] * P_transitions[k][1] # b) P(X2 = 1) P_X2 = 0.0 for i in [0, 1, 2]: for k in [0, 1, 2]: P_X2 += P_X0[i] * P_transitions[i][k] * P_transitions[k][1] # c) P(X2 = 1, X0 = 1) P_X2_and_X0_1 = P_X0[1] * P_X2_given_X0_1 # --- Wyniki --- print(f"RozkĹ‚ad poczÄ…tkowy: P(X0=0)={p_0:.4f}, P(X0=1)={p_1:.4f}, P(X0=2)={p_2:.4f}") print("\nMacierz przejĹ›Ä‡:") for i in [0, 1, 2]: for j in [0, 1, 2]: print(f"P({i}->{j}) = {P_transitions[i][j]:.4f}") print("\nWyniki:") print(f"a) P(X2 = 1 | X0 = 1) = {P_X2_given_X0_1:.4f}") print(f"b) P(X2 = 1) = {P_X2:.4f}") print(f"c) P(X2 = 1, X0 = 1) = {P_X2_and_X0_1:.4f}")

import numpy as np class lancuchMarkowa: def __init__(self, trajektorie): self.trajektorie = trajektorie self.stany = sorted(set([s for traj in trajektorie for s in traj])) self.n = max(self.stany) + 1 self.macPP = self._budujMacPP() self.pocz_prob = self._estymujPrawdPoczatkowe() def _budujMacPP(self): m = np.zeros((self.n, self.n)) for traj in self.trajektorie: for i in range(len(traj) - 1): a = traj[i] b = traj[i+1] m[a][b] += 1 for i in range(self.n): if m[i].sum() > 0: m[i] /= m[i].sum() return m def _estymujPrawdPoczatkowe(self): licznik = np.zeros(self.n) for traj in self.trajektorie: licznik[traj[0]] += 1 return licznik / licznik.sum() def pokazMacPP(self): print("Macierz przejść:") for i in range(self.n): print(f"{i}: {self.macPP[i]}") def pokazPoczProb(self): print("Rozkład początkowy:") for i in range(self.n): print(f"P(X0 = {i}) = {self.pocz_prob[i]}") def P_X2_eq_1_given_X0_eq_1(self): return sum(self.macPP[1][x] * self.macPP[x][1] for x in range(self.n)) def P_X2_eq_1(self): wynik = 0.0 for x0 in range(self.n): for x1 in range(self.n): wynik += self.pocz_prob[x0] * self.macPP[x0][x1] * self.macPP[x1][1] return wynik def P_X2_eq_1_and_X0_eq_1(self): return self.pocz_prob[1] * self.P_X2_eq_1_given_X0_eq_1() # Wczytanie danych z pliku with open("losowe_dane_3.txt", "r") as f: trajektorie = [list(map(int, line.strip().split(','))) for line in f if line.strip()] LM = lancuchMarkowa(trajektorie) # Wyniki LM.pokazPoczProb() print() LM.pokazMacPP() print("\nObliczenia:") print("a) P(X2 = 1 | X0 = 1) =", LM.P_X2_eq_1_given_X0_eq_1()) print("b) P(X2 = 1) =", LM.P_X2_eq_1()) print("c) P(X2 = 1, X0 = 1) =", LM.P_X2_eq_1_and_X0_eq_1())

import numpy as np import matplotlib.pyplot as plt # Stałe a, b, c, d = 4, 5, -2, -1 lambda_poisson = (1 + b) / 2 # intensywność dla Poissona # Funkcja generująca próbki X_t def generate_X(t, n_samples=10000): U = np.random.uniform(0, a, size=n_samples) # U ~ U[0, a] V = np.random.poisson(lam=lambda_poisson, size=n_samples) # V ~ Poiss((1 + b)/2) return c * t + U + d * V # Wartości czasu t t_values = np.linspace(0, 10, 100) E_Xt = [] Var_Xt = [] P_Xt_range = [] # Granice z podpunktu (g) lower_bound = min(5*a, c, b, d) / 2 upper_bound = max(5*a, c, b, d) / 2 # Obliczenia dla każdego t for t in t_values: Xt = generate_X(t) E_Xt.append(np.mean(Xt)) Var_Xt.append(np.var(Xt)) P_Xt_range.append(np.mean((Xt > lower_bound) & (Xt < upper_bound))) # Wykresy plt.figure(figsize=(12, 8)) plt.subplot(3, 1, 1) plt.plot(t_values, E_Xt) plt.title("E[X_t]") plt.grid() plt.subplot(3, 1, 2) plt.plot(t_values, Var_Xt, color='orange') plt.title("Var[X_t]") plt.grid() plt.subplot(3, 1, 3) plt.plot(t_values, P_Xt_range, color='green') plt.axhline(0.5, linestyle='--', color='gray') plt.title(f"P({lower_bound:.2f} < X_t < {upper_bound:.2f})") plt.grid() plt.tight_layout() plt.show()

